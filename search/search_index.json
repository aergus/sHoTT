{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sHoTT This is a formalisation library for simplicial Homotopy Type Theory (sHoTT). The formalisations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes strongly based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"About"},{"location":"#shott","text":"This is a formalisation library for simplicial Homotopy Type Theory (sHoTT). The formalisations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes strongly based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"sHoTT"},{"location":"simplicial-hott/03-simplicial-type-theory/","text":"3. Simplicial Type Theory These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Simplicies and their subshapes Simplicies: -- 1-simplex #def \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP -- 2-simplex #def \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : {(ts : 2 * 2) | \u0394\u00b2 ts} -> TOPE := \\{ts : 2 * 2 | \u0394\u00b2 ts} -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (t : 2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (t : (2 * 2) * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 More to be done. Joins of simplices To be done.","title":"Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory/#3-simplicial-type-theory","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"3. Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory/#simplicies-and-their-subshapes","text":"Simplicies: -- 1-simplex #def \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP -- 2-simplex #def \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : {(ts : 2 * 2) | \u0394\u00b2 ts} -> TOPE := \\{ts : 2 * 2 | \u0394\u00b2 ts} -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (t : 2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (t : (2 * 2) * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 More to be done.","title":"Simplicies and their subshapes"},{"location":"simplicial-hott/03-simplicial-type-theory/#joins-of-simplices","text":"To be done.","title":"Joins of simplices"},{"location":"simplicial-hott/04-extension-types/","text":"4. Equivalences involving extension types These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/ Commutation of arguments and currying -- [RS17, Theorem 4.1] #def flip-ext-fun (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : <{t : I | phi t } -> (x : X) -> Y t x >) : Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := (\\g x t -> g t x, -- the one-way map ((\\h t x -> (h x) t, -- the retraction \\g -> refl), -- the retracting homotopy (\\h t x -> (h x) t, -- the section \\h -> refl))) -- the section homotopy #def flip-ext-fun-inv (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : <{t : I | phi t } -> (x : X) -> Y t x >) : Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := (\\h t x -> (h x) t, -- the one-way map ((\\g x t -> g t x, -- the retraction \\h -> refl), -- the retracting homotopy (\\g x t -> g t x, -- the section \\g -> refl))) -- [RS17, Theorem 4.2] #def curry-uncurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := (\\g (t, s) -> (g t) s, -- the one way map ((\\h t s -> h (t , s) -- its retraction ,\\g -> refl), -- the retracting homotopy (\\h t s -> h (t , s) -- its section ,\\h -> refl))) -- the section homotopy #def uncurry-opcurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := (\\h s t -> h (t , s) , -- the one way map ((\\g (t, s) -> (g s) t -- its retraction ,\\h -> refl), -- the retracting homotopy (\\g (t, s) -> (g s) t -- its section ,\\g -> refl))) -- the section homotopy #def fubini (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f) Extending into \u2211-types (the non-axiom of choice) -- [RS17, Theorem 4.3] #def axiom-choice (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : psi -> U) (Y : <{t : I | psi t} -> (x : X t) -> U >) (a : <{t : I | phi t} -> X t >) (b : <{t : I | phi t} -> Y t (a t) >) : Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := (\\g -> (\\t -> (first (g t)), \\t -> second (g t)) , -- the one way map ((\\h t -> ((first h) t, (second h) t) -- its retraction , \\g -> refl), -- the retracting homotopy (\\h t -> ((first h) t, (second h) t) -- its section , \\h -> refl))) -- the section homotopy Composites and unions of cofibrations -- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' (I : CUBE) (chi psi phi : I -> TOPE) (X : chi -> U) (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) : Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.5] #def cofibration_union (I : CUBE) (phi psi : I -> TOPE) (X : <{t : I | phi t \\/ psi t} -> U >) (a : <{t : I | psi t} -> X t >) : Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := (\\h -> \\t -> h t, ((\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl), (\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl))) Relative function extensionality A more complete treatment still needs to be done. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : <{t : I | phi t } -> A t >) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f = g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv (extext : ExtExt) (I : CUBE) (psi : I -> TOPE) (A B : psi -> U) (fibequiv : <{t : I | psi t } -> (Eq (A t) (B t)) >) : Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := ((\\a t -> (first (fibequiv t)) (a t)), (((\\b t -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\t -> BOT) A (\\u -> recBOT) (\\t -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\t -> (second (first (second (fibequiv t)))) (a t))), ((\\b t -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\t -> BOT) B (\\u -> recBOT) (\\t -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\t -> (second (second (second (fibequiv t)))) (b t))))))","title":"Extension Types"},{"location":"simplicial-hott/04-extension-types/#4-equivalences-involving-extension-types","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"4. Equivalences involving extension types"},{"location":"simplicial-hott/04-extension-types/#prerequisites","text":"hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/","title":"Prerequisites"},{"location":"simplicial-hott/04-extension-types/#commutation-of-arguments-and-currying","text":"-- [RS17, Theorem 4.1] #def flip-ext-fun (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : <{t : I | phi t } -> (x : X) -> Y t x >) : Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := (\\g x t -> g t x, -- the one-way map ((\\h t x -> (h x) t, -- the retraction \\g -> refl), -- the retracting homotopy (\\h t x -> (h x) t, -- the section \\h -> refl))) -- the section homotopy #def flip-ext-fun-inv (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : U) (Y : psi -> X -> U) (f : <{t : I | phi t } -> (x : X) -> Y t x >) : Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := (\\h t x -> (h x) t, -- the one-way map ((\\g x t -> g t x, -- the retraction \\h -> refl), -- the retracting homotopy (\\g x t -> g t x, -- the section \\g -> refl))) -- [RS17, Theorem 4.2] #def curry-uncurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := (\\g (t, s) -> (g t) s, -- the one way map ((\\h t s -> h (t , s) -- its retraction ,\\g -> refl), -- the retracting homotopy (\\h t s -> h (t , s) -- its section ,\\h -> refl))) -- the section homotopy #def uncurry-opcurry (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := (\\h s t -> h (t , s) , -- the one way map ((\\g (t, s) -> (g s) t -- its retraction ,\\h -> refl), -- the retracting homotopy (\\g (t, s) -> (g s) t -- its section ,\\g -> refl))) -- the section homotopy #def fubini (I J : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (zeta : J -> TOPE) (chi : zeta -> TOPE) (X : psi -> zeta -> U) (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) : Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f)","title":"Commutation of arguments and currying"},{"location":"simplicial-hott/04-extension-types/#extending-into-types-the-non-axiom-of-choice","text":"-- [RS17, Theorem 4.3] #def axiom-choice (I : CUBE) (psi : I -> TOPE) (phi : psi -> TOPE) (X : psi -> U) (Y : <{t : I | psi t} -> (x : X t) -> U >) (a : <{t : I | phi t} -> X t >) (b : <{t : I | phi t} -> Y t (a t) >) : Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := (\\g -> (\\t -> (first (g t)), \\t -> second (g t)) , -- the one way map ((\\h t -> ((first h) t, (second h) t) -- its retraction , \\g -> refl), -- the retracting homotopy (\\h t -> ((first h) t, (second h) t) -- its section , \\h -> refl))) -- the section homotopy","title":"Extending into \u2211-types (the non-axiom of choice)"},{"location":"simplicial-hott/04-extension-types/#composites-and-unions-of-cofibrations","text":"-- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' (I : CUBE) (chi psi phi : I -> TOPE) (X : chi -> U) (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) : Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := (\\h -> (\\t -> h t, \\t -> h t), ((\\fg t -> (second fg) t, \\h -> refl), ((\\fg t -> (second fg) t, \\h -> refl)))) -- [RS17, Theorem 4.5] #def cofibration_union (I : CUBE) (phi psi : I -> TOPE) (X : <{t : I | phi t \\/ psi t} -> U >) (a : <{t : I | psi t} -> X t >) : Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := (\\h -> \\t -> h t, ((\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl), (\\g -> \\t -> recOR(phi t |-> g t, psi t |-> a t), \\h -> refl)))","title":"Composites and unions of cofibrations"},{"location":"simplicial-hott/04-extension-types/#relative-function-extensionality","text":"A more complete treatment still needs to be done. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : <{t : I | phi t } -> A t >) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f = g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv (extext : ExtExt) (I : CUBE) (psi : I -> TOPE) (A B : psi -> U) (fibequiv : <{t : I | psi t } -> (Eq (A t) (B t)) >) : Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := ((\\a t -> (first (fibequiv t)) (a t)), (((\\b t -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\t -> BOT) A (\\u -> recBOT) (\\t -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\t -> (second (first (second (fibequiv t)))) (a t))), ((\\b t -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\t -> BOT) B (\\u -> recBOT) (\\t -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\t -> (second (second (second (fibequiv t)))) (b t))))))","title":"Relative function extensionality"},{"location":"simplicial-hott/05-segal-types/","text":"Segal Types These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/1-paths.rzk - we require basic path algebra hott/2-contractible.rzk - we require the notion of contractible types and the data associated to a proof of contractibility hott/total-space.rzk \u2014 we rely on contractible-fibers-projection-equiv and total-space-projection in the proof of Theorem 5.5 3-simplicial-type-theory.md \u2014 we rely on definitions of simplicies and their subshapes 4-extension-types.md \u2014 we use the fubini theorem and extension extensionality Hom types Extension types are used to define the type of arrows between fixed terms: -- [RS17, Definition 5.1] -- The type of arrows in A from x to y #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U := (t : \u0394\u00b9) -> A [ -- (hom A x y) is a 1-simplex (an arrow) in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U := { (t1, t2) : \u0394\u00b2 } -> A [ -- (hom2 A x y z f g h) is a 2-simplex (triangle) in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] The Segal condition A type is Segal if every composable pair of arrows has a unique composite. -- [RS17, Definition 5.3] #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in isSegal. #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := total-path-to-base-path (hom A x z) (\\k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha)) Characterizing Segal types Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> -- \\{(t, s) : 2 * 2 | \u039b (t, s) } -> -- try \\{(t, s) : \u039b } or with () recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) -- A type. (alpha : \u0394\u00b2 -> A) -- A commutative triangle. : \u039b -> A := \\t -> alpha t -- An alternate definition of Segal types. #def isSegal' (A : U) -- A type. : U := isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}), (\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5]; these notions are equivalent, not just logically equivalent, because they are both propositions over A #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A) Segal function and extension types Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality defined in 4-equivalences.rzk (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal))) Identity All types have identity arrows and witnesses to the identity composition law. -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f) Associativity We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing two copies of the triangle along the common diagonal edge. := \\(t, s) -> recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) -- for use in the proof of associativity #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) -- the Segal-comp-witness-square as an arrow in the arrow type #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) Homotopies To be done. Anodyne maps To be done.","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types/#segal-types","text":"These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types/#prerequisites","text":"hott/1-paths.rzk - we require basic path algebra hott/2-contractible.rzk - we require the notion of contractible types and the data associated to a proof of contractibility hott/total-space.rzk \u2014 we rely on contractible-fibers-projection-equiv and total-space-projection in the proof of Theorem 5.5 3-simplicial-type-theory.md \u2014 we rely on definitions of simplicies and their subshapes 4-extension-types.md \u2014 we use the fubini theorem and extension extensionality","title":"Prerequisites"},{"location":"simplicial-hott/05-segal-types/#hom-types","text":"Extension types are used to define the type of arrows between fixed terms: -- [RS17, Definition 5.1] -- The type of arrows in A from x to y #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U := (t : \u0394\u00b9) -> A [ -- (hom A x y) is a 1-simplex (an arrow) in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] Extension types are also used to define the type of commutative triangles: -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U := { (t1, t2) : \u0394\u00b2 } -> A [ -- (hom2 A x y z f g h) is a 2-simplex (triangle) in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ]","title":"Hom types"},{"location":"simplicial-hott/05-segal-types/#the-segal-condition","text":"A type is Segal if every composable pair of arrows has a unique composite. -- [RS17, Definition 5.3] #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) Segal types have a composition functor and witnesses to the composition relation: -- Composition is written in diagrammatic order to match the order of arguments in isSegal. #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) Composition in a Segal type is unique in the following sense. If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) = h := total-path-to-base-path (hom A x z) (\\k -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha))","title":"The Segal condition"},{"location":"simplicial-hott/05-segal-types/#characterizing-segal-types","text":"Our aim is to prove that a type is Segal if and only if the horn-restriction map, defined below, is an equivalence. -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> -- \\{(t, s) : 2 * 2 | \u039b (t, s) } -> -- try \\{(t, s) : \u039b } or with () recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) -- A type. (alpha : \u0394\u00b2 -> A) -- A commutative triangle. : \u039b -> A := \\t -> alpha t -- An alternate definition of Segal types. #def isSegal' (A : U) -- A type. : U := isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (horn-restriction A) Now we prove this definition is equivalent to the original one. -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}), (\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5]; these notions are equivalent, not just logically equivalent, because they are both propositions over A #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A)","title":"Characterizing Segal types"},{"location":"simplicial-hott/05-segal-types/#segal-function-and-extension-types","text":"Using the new characterization of Segal types, we can show that the type of functions or extensions into a family of Segal types is again a Segal type. -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality defined in 4-equivalences.rzk (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal)))","title":"Segal function and extension types"},{"location":"simplicial-hott/05-segal-types/#identity","text":"All types have identity arrows and witnesses to the identity composition law. -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s In a Segal type, where composition is unique, it follows that composition with an identity arrow recovers the original arrow. Thus, an identity axiom was not needed in the definition of Segal types. -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f)","title":"Identity"},{"location":"simplicial-hott/05-segal-types/#associativity","text":"We now prove that composition in a Segal type is associative, by using the fact that the type of arrows in a Segal type is itself a Segal type. #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing two copies of the triangle along the common diagonal edge. := \\(t, s) -> recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) -- for use in the proof of associativity #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) -- the Segal-comp-witness-square as an arrow in the arrow type #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h)","title":"Associativity"},{"location":"simplicial-hott/05-segal-types/#homotopies","text":"To be done.","title":"Homotopies"},{"location":"simplicial-hott/05-segal-types/#anodyne-maps","text":"To be done.","title":"Anodyne maps"},{"location":"simplicial-hott/06-2cat-of-segal-types/","text":"The 2-category of Segal types These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites TODO -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-arr\" to avoid conflicting with \"ap\". #def ap-arr (A B : U) (F : A -> B) (x y : A) (f : hom A x y) : hom B (F x) (F y) := \\t -> F (f t) -- [RS17, Proposition 6.1] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id (extext : ExtExt) (A B : U) (F : A -> B) (x : A) : (ap-arr A B F x x (id-arr A x)) = (id-arr B (F x)) := extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> B) (\\t -> recOR( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-arr A B F x x (id-arr A x)) (id-arr B (F x)) (\\t -> refl)","title":"2-Category of Segal Types"},{"location":"simplicial-hott/06-2cat-of-segal-types/#the-2-category-of-segal-types","text":"These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The 2-category of Segal types"},{"location":"simplicial-hott/06-2cat-of-segal-types/#prerequisites","text":"TODO -- [RS17, Section 6.1] -- Action of maps on homs. Called \"ap-arr\" to avoid conflicting with \"ap\". #def ap-arr (A B : U) (F : A -> B) (x y : A) (f : hom A x y) : hom B (F x) (F y) := \\t -> F (f t) -- [RS17, Proposition 6.1] -- Preservation of identities follows from extension extensionality because these arrows are pointwise equal. #def functors-pres-id (extext : ExtExt) (A B : U) (F : A -> B) (x : A) : (ap-arr A B F x x (id-arr A x)) = (id-arr B (F x)) := extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> B) (\\t -> recOR( t === 0_2 |-> F x, t === 1_2 |-> F x)) (ap-arr A B F x x (id-arr A x)) (id-arr B (F x)) (\\t -> refl)","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete/","text":"Discrete types These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites TODO The definition -- [RS17, Definition 7.1] -- Discrete types are types in which the hom-types are canonically equivalent to identity types. #def id-to-arr (A : U) -- A type. (x y : A) -- Two points of type A. (p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete (A : U) -- A type. : U := (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"Discrete Types"},{"location":"simplicial-hott/07-discrete/#discrete-types","text":"These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Discrete types"},{"location":"simplicial-hott/07-discrete/#prerequisites","text":"TODO","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete/#the-definition","text":"-- [RS17, Definition 7.1] -- Discrete types are types in which the hom-types are canonically equivalent to identity types. #def id-to-arr (A : U) -- A type. (x y : A) -- Two points of type A. (p : x = y) -- A path p from x to y in A. : hom A x y -- An arrow p from x to y in A. := idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete (A : U) -- A type. : U := (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"The definition"},{"location":"simplicial-hott/08-covariant/","text":"Covariantly functorial type families These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites TODO -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> \\v -> <{t : 2 | \u0394\u00b9 t } -> C (f t) [ \u2202\u0394\u00b9 t |-> recOR(t === 0_2, t === 1_2, u, v) ]> -- dependent hom with specified domain #def dhomFrom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> (\u2211 (v : C y), dhom A x y f C u v) -- [RS17, Section 8 Prelim] #def dhom2 : (A : U) -> (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> (h : hom A x z) -> (alpha : hom2 A x y z f g h) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> (w : C z) -> (ff : dhom A x y f C u v) -> (gg : dhom A y z g C v w) -> (hh : dhom A x z h C u w) -> U := \\A -> \\x -> \\y -> \\z -> \\f -> \\g -> \\h -> \\alpha -> \\C -> \\u -> \\v -> \\w -> \\ff -> \\gg -> \\hh -> <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [ \u2202\u0394\u00b2 (t1, t2) |-> recOR(t2 === 0_2, t1 === 1_2 \\/ t2 === t1, ff t1, recOR(t1 === 1_2, t2 === t1, gg t2, hh t2)) ]> -- [RS17, Definition 8.2] #def isCovFam : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> isContr (\u2211 (v : C y), dhom A x y f C u v) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C) -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (C : A -> U) (CisCov : isCovFam A C) (x y : A) (f : hom A x y) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift : (A : U) -> (C : A -> U) -> (CisCov : isCovFam A C) -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> (dhom A x y f C u (covTrans A C CisCov x y f u)) := \\A -> \\C -> \\CisCov -> \\x -> \\y -> \\f -> \\u -> second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, Remark 8.3] -- TODO: Seems broken ATM -- #def reindexOfCovFamIsCov : (A : U) -> (B : U) -> (F : (b : B) -> A) -> (C : (a : A) -> U) -> (AisCovFam : isCovFam A C) -> (isCovFam B (reindex A B F C)) -- := \\A -> \\B -> \\F -> \\C -> \\AisCovFam -> \\x -> \\y -> \\f -> \\u -> -- ( -- (contraction-center (\u2211 (v : C (F y)), -- (dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u), -- (contracting-htpy (\u2211 (v : C (F y)), -- dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u) -- ) -- ) -- [RS17, alternative def. from Proposition 8.4] #def isCovFam' : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr <{t : 2 | \u0394\u00b9 t} -> C(f t) > -- [RS17, Proposition 8.4] -- We should prove this in one step since this amounts to transporting along equivalent types of lifting --#def isCovFam-iff-CovFam' : (A : U) -> (C : (a : A) -> (_ : isCovFam A C) -> --isCovFam' A C -- := TODO -- [RS17, Proposition 8.16, Part 1] -- Covariant families preserve composition -- #def covPresComp -- (A : U) -- (C : A -> U) -- (x y z : A) -- (f : hom A x y) -- (g : hom A y z) -- (h : hom A x z) -- (u : C x) -- -> TODO -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities -- #def covPresId -- (A : U) -- (C : A -> U) -- (CisCov : isCovFam A C) -- (x : A) : (homotopy -- (C x) -- (C x) -- (\\u -> (covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- := \\u -> (first (contractible-connecting-htpy -- (dhomFrom A x x (id-arr A x) C u) -- (CisCov) -- ((covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- ) -- covTrans : (A : U) -> (C : A -> U) -> (_ : isCovFam A C) -- -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> C y -- :=","title":"Covariantly Functorial Type Families"},{"location":"simplicial-hott/08-covariant/#covariantly-functorial-type-families","text":"These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Covariantly functorial type families"},{"location":"simplicial-hott/08-covariant/#prerequisites","text":"TODO -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> \\v -> <{t : 2 | \u0394\u00b9 t } -> C (f t) [ \u2202\u0394\u00b9 t |-> recOR(t === 0_2, t === 1_2, u, v) ]> -- dependent hom with specified domain #def dhomFrom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> (\u2211 (v : C y), dhom A x y f C u v) -- [RS17, Section 8 Prelim] #def dhom2 : (A : U) -> (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> (h : hom A x z) -> (alpha : hom2 A x y z f g h) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> (w : C z) -> (ff : dhom A x y f C u v) -> (gg : dhom A y z g C v w) -> (hh : dhom A x z h C u w) -> U := \\A -> \\x -> \\y -> \\z -> \\f -> \\g -> \\h -> \\alpha -> \\C -> \\u -> \\v -> \\w -> \\ff -> \\gg -> \\hh -> <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [ \u2202\u0394\u00b2 (t1, t2) |-> recOR(t2 === 0_2, t1 === 1_2 \\/ t2 === t1, ff t1, recOR(t1 === 1_2, t2 === t1, gg t2, hh t2)) ]> -- [RS17, Definition 8.2] #def isCovFam : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> isContr (\u2211 (v : C y), dhom A x y f C u v) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C) -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (C : A -> U) (CisCov : isCovFam A C) (x y : A) (f : hom A x y) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift : (A : U) -> (C : A -> U) -> (CisCov : isCovFam A C) -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> (dhom A x y f C u (covTrans A C CisCov x y f u)) := \\A -> \\C -> \\CisCov -> \\x -> \\y -> \\f -> \\u -> second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, Remark 8.3] -- TODO: Seems broken ATM -- #def reindexOfCovFamIsCov : (A : U) -> (B : U) -> (F : (b : B) -> A) -> (C : (a : A) -> U) -> (AisCovFam : isCovFam A C) -> (isCovFam B (reindex A B F C)) -- := \\A -> \\B -> \\F -> \\C -> \\AisCovFam -> \\x -> \\y -> \\f -> \\u -> -- ( -- (contraction-center (\u2211 (v : C (F y)), -- (dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u), -- (contracting-htpy (\u2211 (v : C (F y)), -- dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u) -- ) -- ) -- [RS17, alternative def. from Proposition 8.4] #def isCovFam' : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr <{t : 2 | \u0394\u00b9 t} -> C(f t) > -- [RS17, Proposition 8.4] -- We should prove this in one step since this amounts to transporting along equivalent types of lifting --#def isCovFam-iff-CovFam' : (A : U) -> (C : (a : A) -> (_ : isCovFam A C) -> --isCovFam' A C -- := TODO -- [RS17, Proposition 8.16, Part 1] -- Covariant families preserve composition -- #def covPresComp -- (A : U) -- (C : A -> U) -- (x y z : A) -- (f : hom A x y) -- (g : hom A y z) -- (h : hom A x z) -- (u : C x) -- -> TODO -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities -- #def covPresId -- (A : U) -- (C : A -> U) -- (CisCov : isCovFam A C) -- (x : A) : (homotopy -- (C x) -- (C x) -- (\\u -> (covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- := \\u -> (first (contractible-connecting-htpy -- (dhomFrom A x x (id-arr A x) C u) -- (CisCov) -- ((covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- ) -- covTrans : (A : U) -> (C : A -> U) -> (_ : isCovFam A C) -- -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> C y -- :=","title":"Prerequisites"},{"location":"simplicial-hott/09-yoneda/","text":"The Yoneda lemma These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/* - we require various prerequisites from homotopy type theory, for instance the axiom of function extensionality 3-simplicial-type-theory.md \u2014 we rely on definitions of simplicies and their subshapes 4-extension-types.md \u2014 we use the fubini theorem and extension extensionality 5-segal-types.md - we make heavy use of the notion of Segal types Natural transformations between representable functors In what follows, we'll consider a Segal type A with two fixed terms a and b. We show that a fiberwise map phi : (z : A) -> hom A a z -> hom A b z automatically defines a natural transformation, despite appearing only to define the components of such. -- This unfolds a composition triangle to a square with an identity component #def id-domain-square (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a x y : A) -- Three objects (g : hom A a x) (k : hom A x y) : (s : \u0394\u00b9) -> hom A a (k s) := \\s t -> recOR(t <= s |-> (id-comp-witness A a y (Segal-comp A AisSegal a x y g k)) (s , t), s <= t |-> (Segal-comp-witness A AisSegal a x y g k) (t , s)) -- We apply the transformation phi to the square just constructed. #def id-domain-square-transformation (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (s : \u0394\u00b9) -> hom A b (k s) := \\s -> phi (k s) (\\t -> (id-domain-square A AisSegal a x y g k s t)) -- This extracts the diagonal composite of the square. #def id-domain-square-transformation-diagonal (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : hom A b y := \\t -> id-domain-square-transformation A AisSegal a b x y g k phi t t -- One half of the id-domain-square-transformation. #def composite-of-transformation (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : hom2 A b x y (phi x g) k (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := \\(t, s) -> (id-domain-square-transformation A AisSegal a b x y g k phi s t) #def composite-of-transformation-coherence (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (Segal-comp A AisSegal b x y (phi x g) k) = (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := Segal-comp-uniqueness A AisSegal b x y (phi x g) k (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (composite-of-transformation A AisSegal a b x y g k phi) -- The other half of the id-domain-square-transformation. #def transformation-of-composite (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : hom2 A b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k)) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := \\(s, t) -> (id-domain-square-transformation A AisSegal a b x y g k phi s t) #def transformation-of-composite-coherence (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (Segal-comp A AisSegal b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k))) = (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := Segal-comp-uniqueness A AisSegal b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k)) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (transformation-of-composite A AisSegal a b x y g k phi) #def transformation-of-composite-coherence-simplified (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (phi y (Segal-comp A AisSegal a x y g k)) = (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := zag-zig-concat (hom A b y) (phi y (Segal-comp A AisSegal a x y g k)) (Segal-comp A AisSegal b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k))) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (Segal-id-comp A AisSegal b y (phi y (Segal-comp A AisSegal a x y g k))) (transformation-of-composite-coherence A AisSegal a b x y g k phi) #def fiberwise-is-natural (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects. (phi : (z : A) -> hom A a z -> hom A b z) -- A natural transformation (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. : Segal-comp A AisSegal b x y (phi x g) k = phi y (Segal-comp A AisSegal a x y g k) := zig-zag-concat (hom A b y) (Segal-comp A AisSegal b x y (phi x g) k) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (phi y (Segal-comp A AisSegal a x y g k)) (composite-of-transformation-coherence A AisSegal a b x y g k phi) (transformation-of-composite-coherence-simplified A AisSegal a b x y g k phi) The Yoneda maps The Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> hom A b z of natural transformations between representable functors and the type hom A b a of arrows between the representing objects. -- The map evid evaluates a natural transformation between representable functors at the identity arrow. #def evid (A : U) -- The ambient type. (a b : A) -- The representing objects : ((z : A) -> hom A a z -> hom A b z) -> hom A b a := \\phi -> phi a (id-arr A a) -- The inverse map only exists for Segal types. #def yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects : hom A b a -> ((z : A) -> hom A a z -> hom A b z) := \\f z g -> Segal-comp A AisSegal b a z f g The Yoneda composites It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (f : hom A b a) : (evid A a b) ((yon A AisSegal a b) f) = f := Segal-comp-id A AisSegal b a f -- The other composite carries phi to an a priori distinct natural transformation. -- We first show that these are pointwise equal at all x : A and g : hom A a x in two steps. -- The first step: #def yon-evid-partial (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) (g : hom A a x) : ((yon A AisSegal a b)((evid A a b) phi)) x g = phi x (Segal-comp A AisSegal a a x (id-arr A a) g) -- phi x g := fiberwise-is-natural A AisSegal a b a x phi (id-arr A a) g -- The second step: #def yon-evid-ap (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) (g : hom A a x) : phi x (Segal-comp A AisSegal a a x (id-arr A a) g) = phi x g := ap (hom A a x) (hom A b x) (Segal-comp A AisSegal a a x (id-arr A a) g) g (phi x) (Segal-id-comp A AisSegal a x g) -- The composite yon-evid of phi equals phi at all x : A and g : hom A a x. #def yon-evid-twice-pointwise (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) (g : hom A a x) : ((yon A AisSegal a b)((evid A a b) phi)) x g = phi x g := concat (hom A b x) (((yon A AisSegal a b)((evid A a b) phi)) x g) (phi x (Segal-comp A AisSegal a a x (id-arr A a) g)) (phi x g) (yon-evid-partial A AisSegal a b phi x g) (yon-evid-ap A AisSegal a b phi x g) -- By funext, these are equals as functions of g pointwise in x. #def yon-evid-once-pointwise (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) : ((yon A AisSegal a b)((evid A a b) phi)) x = phi x := funext (hom A a x) (\\g -> hom A b x) (\\g -> (((yon A AisSegal a b)((evid A a b) phi)) x g)) (\\g -> (phi x g)) (\\g -> yon-evid-twice-pointwise A AisSegal a b phi x g) -- By funext again, these are equal as functions of x and g. #def yon-evid (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) : ((yon A AisSegal a b)((evid A a b) phi)) = phi := funext A (\\x -> (hom A a x -> hom A b x)) (\\x -> (((yon A AisSegal a b)((evid A a b) phi)) x)) (\\x -> (phi x)) (\\x -> yon-evid-once-pointwise funext A AisSegal a b phi x) The Yoneda lemma The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects : isEquiv ((z : A) -> hom A a z -> hom A b z) (hom A b a) (evid A a b) := ((yon A AisSegal a b, yon-evid funext A AisSegal a b), (yon A AisSegal a b, evid-yon A AisSegal a b))","title":"The Yoneda Lemma"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-lemma","text":"These formalisations correspond to Section 9 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The Yoneda lemma"},{"location":"simplicial-hott/09-yoneda/#prerequisites","text":"hott/* - we require various prerequisites from homotopy type theory, for instance the axiom of function extensionality 3-simplicial-type-theory.md \u2014 we rely on definitions of simplicies and their subshapes 4-extension-types.md \u2014 we use the fubini theorem and extension extensionality 5-segal-types.md - we make heavy use of the notion of Segal types","title":"Prerequisites"},{"location":"simplicial-hott/09-yoneda/#natural-transformations-between-representable-functors","text":"In what follows, we'll consider a Segal type A with two fixed terms a and b. We show that a fiberwise map phi : (z : A) -> hom A a z -> hom A b z automatically defines a natural transformation, despite appearing only to define the components of such. -- This unfolds a composition triangle to a square with an identity component #def id-domain-square (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a x y : A) -- Three objects (g : hom A a x) (k : hom A x y) : (s : \u0394\u00b9) -> hom A a (k s) := \\s t -> recOR(t <= s |-> (id-comp-witness A a y (Segal-comp A AisSegal a x y g k)) (s , t), s <= t |-> (Segal-comp-witness A AisSegal a x y g k) (t , s)) -- We apply the transformation phi to the square just constructed. #def id-domain-square-transformation (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (s : \u0394\u00b9) -> hom A b (k s) := \\s -> phi (k s) (\\t -> (id-domain-square A AisSegal a x y g k s t)) -- This extracts the diagonal composite of the square. #def id-domain-square-transformation-diagonal (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : hom A b y := \\t -> id-domain-square-transformation A AisSegal a b x y g k phi t t -- One half of the id-domain-square-transformation. #def composite-of-transformation (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : hom2 A b x y (phi x g) k (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := \\(t, s) -> (id-domain-square-transformation A AisSegal a b x y g k phi s t) #def composite-of-transformation-coherence (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (Segal-comp A AisSegal b x y (phi x g) k) = (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := Segal-comp-uniqueness A AisSegal b x y (phi x g) k (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (composite-of-transformation A AisSegal a b x y g k phi) -- The other half of the id-domain-square-transformation. #def transformation-of-composite (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : hom2 A b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k)) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := \\(s, t) -> (id-domain-square-transformation A AisSegal a b x y g k phi s t) #def transformation-of-composite-coherence (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (Segal-comp A AisSegal b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k))) = (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := Segal-comp-uniqueness A AisSegal b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k)) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (transformation-of-composite A AisSegal a b x y g k phi) #def transformation-of-composite-coherence-simplified (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. (phi : (z : A) -> hom A a z -> hom A b z) -- A fiberwise map. : (phi y (Segal-comp A AisSegal a x y g k)) = (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) := zag-zig-concat (hom A b y) (phi y (Segal-comp A AisSegal a x y g k)) (Segal-comp A AisSegal b b y (id-arr A b) (phi y (Segal-comp A AisSegal a x y g k))) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (Segal-id-comp A AisSegal b y (phi y (Segal-comp A AisSegal a x y g k))) (transformation-of-composite-coherence A AisSegal a b x y g k phi) #def fiberwise-is-natural (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b x y : A) -- Four objects. (phi : (z : A) -> hom A a z -> hom A b z) -- A natural transformation (g : hom A a x) -- An arrow from a to x. (k : hom A x y) -- An arrow from b to y. : Segal-comp A AisSegal b x y (phi x g) k = phi y (Segal-comp A AisSegal a x y g k) := zig-zag-concat (hom A b y) (Segal-comp A AisSegal b x y (phi x g) k) (id-domain-square-transformation-diagonal A AisSegal a b x y g k phi) (phi y (Segal-comp A AisSegal a x y g k)) (composite-of-transformation-coherence A AisSegal a b x y g k phi) (transformation-of-composite-coherence-simplified A AisSegal a b x y g k phi)","title":"Natural transformations between representable functors"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-maps","text":"The Yoneda lemma provides an equivalence between the type (z : A) -> hom A a z -> hom A b z of natural transformations between representable functors and the type hom A b a of arrows between the representing objects. -- The map evid evaluates a natural transformation between representable functors at the identity arrow. #def evid (A : U) -- The ambient type. (a b : A) -- The representing objects : ((z : A) -> hom A a z -> hom A b z) -> hom A b a := \\phi -> phi a (id-arr A a) -- The inverse map only exists for Segal types. #def yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects : hom A b a -> ((z : A) -> hom A a z -> hom A b z) := \\f z g -> Segal-comp A AisSegal b a z f g","title":"The Yoneda maps"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-composites","text":"It remains to show that the Yoneda maps are inverses. -- One retraction is straightforward: #def evid-yon (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (f : hom A b a) : (evid A a b) ((yon A AisSegal a b) f) = f := Segal-comp-id A AisSegal b a f -- The other composite carries phi to an a priori distinct natural transformation. -- We first show that these are pointwise equal at all x : A and g : hom A a x in two steps. -- The first step: #def yon-evid-partial (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) (g : hom A a x) : ((yon A AisSegal a b)((evid A a b) phi)) x g = phi x (Segal-comp A AisSegal a a x (id-arr A a) g) -- phi x g := fiberwise-is-natural A AisSegal a b a x phi (id-arr A a) g -- The second step: #def yon-evid-ap (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) (g : hom A a x) : phi x (Segal-comp A AisSegal a a x (id-arr A a) g) = phi x g := ap (hom A a x) (hom A b x) (Segal-comp A AisSegal a a x (id-arr A a) g) g (phi x) (Segal-id-comp A AisSegal a x g) -- The composite yon-evid of phi equals phi at all x : A and g : hom A a x. #def yon-evid-twice-pointwise (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) (g : hom A a x) : ((yon A AisSegal a b)((evid A a b) phi)) x g = phi x g := concat (hom A b x) (((yon A AisSegal a b)((evid A a b) phi)) x g) (phi x (Segal-comp A AisSegal a a x (id-arr A a) g)) (phi x g) (yon-evid-partial A AisSegal a b phi x g) (yon-evid-ap A AisSegal a b phi x g) -- By funext, these are equals as functions of g pointwise in x. #def yon-evid-once-pointwise (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) (x : A) : ((yon A AisSegal a b)((evid A a b) phi)) x = phi x := funext (hom A a x) (\\g -> hom A b x) (\\g -> (((yon A AisSegal a b)((evid A a b) phi)) x g)) (\\g -> (phi x g)) (\\g -> yon-evid-twice-pointwise A AisSegal a b phi x g) -- By funext again, these are equal as functions of x and g. #def yon-evid (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects (phi : (z : A) -> hom A a z -> hom A b z) : ((yon A AisSegal a b)((evid A a b) phi)) = phi := funext A (\\x -> (hom A a x -> hom A b x)) (\\x -> (((yon A AisSegal a b)((evid A a b) phi)) x)) (\\x -> (phi x)) (\\x -> yon-evid-once-pointwise funext A AisSegal a b phi x)","title":"The Yoneda composites"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-lemma_1","text":"The Yoneda lemma says that evaluation at the identity defines an equivalence. #def Yoneda-lemma (funext : FunExt) (A : U) -- The ambient type. (AisSegal : isSegal A) -- A proof that A is Segal. (a b : A) -- The representing objects : isEquiv ((z : A) -> hom A a z -> hom A b z) (hom A b a) (evid A a b) := ((yon A AisSegal a b, yon-evid funext A AisSegal a b), (yon A AisSegal a b, evid-yon A AisSegal a b))","title":"The Yoneda lemma"},{"location":"simplicial-hott/10-rezk-types/","text":"10. Rezk Types These formalisations correspond to Section 10 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Rezk Types"},{"location":"simplicial-hott/10-rezk-types/#10-rezk-types","text":"These formalisations correspond to Section 10 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"10. Rezk Types"},{"location":"simplicial-hott/11-adjunctions/","text":"11. Adjunctions These formalisations correspond to Section 11 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Adjunctions"},{"location":"simplicial-hott/11-adjunctions/#11-adjunctions","text":"These formalisations correspond to Section 11 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"11. Adjunctions"}]}