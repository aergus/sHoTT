{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"sHoTT This is a formalisation library for simplicial Homotopy Type Theory (sHoTT). The formalisations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes strongly based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"About"},{"location":"#shott","text":"This is a formalisation library for simplicial Homotopy Type Theory (sHoTT). The formalisations are implemented using rzk , an experimental proof assistant for a variant of type theory with shapes strongly based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"sHoTT"},{"location":"simplicial-hott/03-simplicial-type-theory/","text":"3. Simplicial Type Theory These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Simplicies and their subshapes Simplicies: -- 1-simplex #def \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP -- 2-simplex #def \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : {(ts : 2 * 2) | \u0394\u00b2 ts} -> TOPE := \\{ts : 2 * 2 | \u0394\u00b2 ts} -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (t : 2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (t : (2 * 2) * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 More to be done. Joins of simplices To be done.","title":"Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory/#3-simplicial-type-theory","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"3. Simplicial Type Theory"},{"location":"simplicial-hott/03-simplicial-type-theory/#simplicies-and-their-subshapes","text":"Simplicies: -- 1-simplex #def \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP -- 2-simplex #def \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t -- 3-simplex #def \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Boundaries of simplices: -- boundary of a 1-simplex #def \u2202\u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> (t === 0_2 \\/ t === 1_2) -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : {(ts : 2 * 2) | \u0394\u00b2 ts} -> TOPE := \\{ts : 2 * 2 | \u0394\u00b2 ts} -> ((second ts) === 0_2 \\/ (first ts) === 1_2 \\/ (second ts) === (first ts)) Horns: -- the (2,1)-horn #def \u039b : (t : 2 * 2) -> TOPE := \\(t, s) -> (s === 0_2 \\/ t === 1_2) Products: -- the product of topes defines the product of shapes #def shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s -- the square as a product #def \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 -- the vertical boundary of the square #def \u2202\u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u2202\u0394\u00b9 \u0394\u00b9 -- the prism from a 2-simplex in an arrow type #def \u0394\u00b2\u00d7\u0394\u00b9 : (t : (2 * 2) * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 More to be done.","title":"Simplicies and their subshapes"},{"location":"simplicial-hott/03-simplicial-type-theory/#joins-of-simplices","text":"To be done.","title":"Joins of simplices"},{"location":"simplicial-hott/04-extension-types/","text":"4. Equivalences involving extension types These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/ A projection, forgetting tope constraints #def extension-projection : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (A : <{t : I | psi t} -> U >) -> (a : <{t : I | phi t} -> A t >) -> (_ : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> <{t : I | psi t} -> A t > := \\I -> \\psi -> \\phi -> \\A -> \\a -> \\f -> \\{t : I | psi t} -> f t Commutation of arguments and currying -- [RS17, Theorem 4.1] #def flip-ext-fun : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t } -> (x : X) -> U >) -> (f : <{t : I | phi t } -> (x : X) -> Y t x >) -> Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\f -> (\\g -> \\x -> \\{t : I | psi t} -> g t x, -- the one-way map; needs the context for t to typecheck ((\\h -> \\{t : I | psi t} -> \\x -> (h x) t, -- the retraction \\g -> refl_{g}), -- the retracting homotopy (\\h -> \\{t : I | psi t} -> \\x -> (h x) t, -- the section \\h -> refl_{h}))) #def flip-ext-fun-inv : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t } -> (x : X) -> U >) -> (f : <{t : I | phi t } -> (x : X) -> Y t x >) -> Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\f -> (\\h -> \\{t : I | psi t} -> \\x -> (h x) t, -- the one-way map ((\\g -> \\x -> \\{t : I | psi t} -> g t x, -- the retraction \\h -> refl_{h}), -- the retracting homotopy (\\g -> \\x -> \\{t : I | psi t} -> g t x, -- the section \\g -> refl_{g}))) -- [RS17, Theorem 4.2] #def curry-uncurry : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (zeta : (s : J) -> TOPE) -> (chi : {(s : J) | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U > >) -> (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) -> Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := \\I -> \\J -> \\psi -> \\phi -> \\zeta -> \\chi -> \\X -> \\f -> (\\g -> \\{(t, s) : I * J | psi t /\\ zeta s} -> (g t) s, -- the one way map ((\\h -> \\{t : I | psi t} -> \\{ s : J | zeta s} -> h (t , s) -- its retraction ,\\g -> refl_{g} ), -- the retracting homotopy (\\h -> \\{t : I | psi t} -> \\{ s : J | zeta s} -> h (t , s) -- its section ,\\h -> refl_{h}))) -- the section homotopy #def uncurry-opcurry : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (zeta : (s : J) -> TOPE) -> (chi : {(s : J) | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U > >) -> (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) -> Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := \\I -> \\J -> \\psi -> \\phi -> \\zeta -> \\chi -> \\X -> \\f -> (\\h -> \\{s : J | zeta s} -> \\{t : I | psi t} -> h (t , s) , -- the one way map ((\\g -> \\{(t, s) : I * J | psi t /\\ zeta s} -> (g s) t -- its retraction ,\\h -> refl_{h} ), -- the retracting homotopy (\\g -> \\{(t, s) : I * J | psi t /\\ zeta s} -> (g s) t -- its section ,\\g -> refl_{g}))) -- the section homotopy #def fubini : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (zeta : (s : J) -> TOPE) -> (chi : {(s : J) | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U > >) -> (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) -> Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := \\I -> \\J -> \\psi -> \\phi -> \\zeta -> \\chi -> \\X -> \\f -> compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f) Extending into \u2211-types (the non-axiom of choice) -- [RS17, Theorem 4.3] #def axiom-choice : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : <{t : I | psi t} -> U >) -> (Y : <{t : I | psi t} -> (x : X t) -> U >) -> (a : <{t : I | phi t} -> X t >) -> (b : <{t : I | phi t} -> Y t (a t) >) -> Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\a -> \\b -> (\\g -> (\\{t : I | psi t} -> (first (g t)), \\{t : I | psi t} -> second (g t)) , -- the one way map ((\\h -> \\{t : I | psi t} -> ((first h) t, (second h) t) -- its retraction , \\g -> refl_{g}), -- the retracting homotopy (\\h -> \\{t : I | psi t} -> ((first h) t, (second h) t) -- its section , \\h -> refl_{h}))) -- the section homotopy Composites and unions of cofibrations -- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' : (I : CUBE) -> (chi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (X : <{t : I | chi t} -> U >) -> (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) -> Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := \\I -> \\chi -> \\psi -> \\phi -> \\X -> \\a -> (\\h -> (\\{t : I | chi t /\\ psi t} -> h t, \\{t : I | chi t} -> h t), ((\\fg -> \\{t : I | chi t} -> (second fg) t, \\h -> refl_{h}), ((\\fg -> \\{t : I | chi t} -> (second fg) t, \\h -> refl_{h})))) -- [RS17, Theorem 4.5] #def cofibration_union : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (X : <{t : I | phi t \\/ psi t} -> U >) -> (a : <{t : I | psi t} -> X t >) -> Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := \\I -> \\phi -> \\psi -> \\X -> \\a -> (\\h -> \\{t : I | phi t} -> h t, ((\\g -> \\{t : I | phi t \\/ psi t} -> recOR(phi t, psi t, g t, a t), \\h -> refl_{h}), (\\g -> \\{t : I | phi t \\/ psi t} -> recOR(phi t, psi t, g t, a t), \\h -> refl_{h}))) Relative function extensionality A more complete treatment still needs to be done. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (A : <{t : I | psi t } -> U >) -> (a : <{t : I | phi t } -> A t >) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f =_{<{t : I | psi t} -> A t [ phi t |-> a t ]>} g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv : (_ : ExtExt) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (A : <{t : I | psi t } -> U >) -> (B : <{t : I | psi t } -> U >) -> (_ : <{t : I | psi t } -> (Eq (A t) (B t)) >) -> Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := \\extext -> \\I -> \\psi -> \\A -> \\B -> \\fibequiv -> ((\\a -> \\{t : I | psi t } -> (first (fibequiv t)) (a t)), (((\\b -> \\{t : I | psi t } -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\{t : I | psi t} -> BOT) A (\\{u : I | BOT} -> recBOT) (\\{t : I | psi t} -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\{t : I | psi t} -> (second (first (second (fibequiv t)))) (a t))), ((\\b -> \\{t : I | psi t } -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\{t : I | psi t} -> BOT) B (\\{u : I | BOT} -> recBOT) (\\{t : I | psi t} -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\{t : I | psi t} -> (second (second (second (fibequiv t)))) (b t))))))","title":"Extension Types"},{"location":"simplicial-hott/04-extension-types/#4-equivalences-involving-extension-types","text":"These formalisations correspond to Section 3 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"4. Equivalences involving extension types"},{"location":"simplicial-hott/04-extension-types/#prerequisites","text":"hott/4-equivalences.rzk \u2014 contains the definitions of Eq and compose_Eq the file hott/4-equivalences.rzk relies in turn on the previous files in hott/","title":"Prerequisites"},{"location":"simplicial-hott/04-extension-types/#a-projection-forgetting-tope-constraints","text":"#def extension-projection : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (A : <{t : I | psi t} -> U >) -> (a : <{t : I | phi t} -> A t >) -> (_ : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> <{t : I | psi t} -> A t > := \\I -> \\psi -> \\phi -> \\A -> \\a -> \\f -> \\{t : I | psi t} -> f t","title":"A projection, forgetting tope constraints"},{"location":"simplicial-hott/04-extension-types/#commutation-of-arguments-and-currying","text":"-- [RS17, Theorem 4.1] #def flip-ext-fun : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t } -> (x : X) -> U >) -> (f : <{t : I | phi t } -> (x : X) -> Y t x >) -> Eq (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\f -> (\\g -> \\x -> \\{t : I | psi t} -> g t x, -- the one-way map; needs the context for t to typecheck ((\\h -> \\{t : I | psi t} -> \\x -> (h x) t, -- the retraction \\g -> refl_{g}), -- the retracting homotopy (\\h -> \\{t : I | psi t} -> \\x -> (h x) t, -- the section \\h -> refl_{h}))) #def flip-ext-fun-inv : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t } -> (x : X) -> U >) -> (f : <{t : I | phi t } -> (x : X) -> Y t x >) -> Eq ((x : X) -> <{t : I | psi t} -> Y t x [ phi t |-> f t x]>) (<{t : I | psi t} -> ((x : X) -> Y t x) [ phi t |-> f t ]>) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\f -> (\\h -> \\{t : I | psi t} -> \\x -> (h x) t, -- the one-way map ((\\g -> \\x -> \\{t : I | psi t} -> g t x, -- the retraction \\h -> refl_{h}), -- the retracting homotopy (\\g -> \\x -> \\{t : I | psi t} -> g t x, -- the section \\g -> refl_{g}))) -- [RS17, Theorem 4.2] #def curry-uncurry : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (zeta : (s : J) -> TOPE) -> (chi : {(s : J) | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U > >) -> (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) -> Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) := \\I -> \\J -> \\psi -> \\phi -> \\zeta -> \\chi -> \\X -> \\f -> (\\g -> \\{(t, s) : I * J | psi t /\\ zeta s} -> (g t) s, -- the one way map ((\\h -> \\{t : I | psi t} -> \\{ s : J | zeta s} -> h (t , s) -- its retraction ,\\g -> refl_{g} ), -- the retracting homotopy (\\h -> \\{t : I | psi t} -> \\{ s : J | zeta s} -> h (t , s) -- its section ,\\h -> refl_{h}))) -- the section homotopy #def uncurry-opcurry : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (zeta : (s : J) -> TOPE) -> (chi : {(s : J) | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U > >) -> (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) -> Eq (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := \\I -> \\J -> \\psi -> \\phi -> \\zeta -> \\chi -> \\X -> \\f -> (\\h -> \\{s : J | zeta s} -> \\{t : I | psi t} -> h (t , s) , -- the one way map ((\\g -> \\{(t, s) : I * J | psi t /\\ zeta s} -> (g s) t -- its retraction ,\\h -> refl_{h} ), -- the retracting homotopy (\\g -> \\{(t, s) : I * J | psi t /\\ zeta s} -> (g s) t -- its section ,\\g -> refl_{g}))) -- the section homotopy #def fubini : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (zeta : (s : J) -> TOPE) -> (chi : {(s : J) | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U > >) -> (f : <{(t, s) : I * J | (phi t /\\ zeta s) \\/ (psi t /\\ chi s)} -> X t s >) -> Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) := \\I -> \\J -> \\psi -> \\phi -> \\zeta -> \\chi -> \\X -> \\f -> compose_Eq (<{t : I | psi t} -> <{ s : J | zeta s} -> X t s [ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) (<{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t , s)]>) (<{s : J | zeta s} -> <{ t : I | psi t} -> X t s [ phi t |-> f (t, s) ]> [ chi s |-> \\{t : I | psi t} -> f (t, s) ]>) (curry-uncurry I J psi phi zeta chi X f) (uncurry-opcurry I J psi phi zeta chi X f)","title":"Commutation of arguments and currying"},{"location":"simplicial-hott/04-extension-types/#extending-into-types-the-non-axiom-of-choice","text":"-- [RS17, Theorem 4.3] #def axiom-choice : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : <{t : I | psi t} -> U >) -> (Y : <{t : I | psi t} -> (x : X t) -> U >) -> (a : <{t : I | phi t} -> X t >) -> (b : <{t : I | phi t} -> Y t (a t) >) -> Eq (<{t : I | psi t} -> (\u2211 (x : X t), Y t x) [ phi t |-> (a t , b t) ]>) (\u2211 (f : (<{t : I | psi t} -> X t [phi t |-> a t ]>)), (<{t : I | psi t} -> Y t (f t) [ phi t |-> b t ]>)) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\a -> \\b -> (\\g -> (\\{t : I | psi t} -> (first (g t)), \\{t : I | psi t} -> second (g t)) , -- the one way map ((\\h -> \\{t : I | psi t} -> ((first h) t, (second h) t) -- its retraction , \\g -> refl_{g}), -- the retracting homotopy (\\h -> \\{t : I | psi t} -> ((first h) t, (second h) t) -- its section , \\h -> refl_{h}))) -- the section homotopy","title":"Extending into \u2211-types (the non-axiom of choice)"},{"location":"simplicial-hott/04-extension-types/#composites-and-unions-of-cofibrations","text":"-- [RS17, Theorem 4.4] -- Reformulated via tope disjunction instead of inclusion. -- See https://github.com/fizruk/rzk/issues/8 #def cofibration_composition' : (I : CUBE) -> (chi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (X : <{t : I | chi t} -> U >) -> (a : <{t : I | chi t /\\ psi t /\\ phi t} -> X t >) -> Eq <{t : I | chi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]> (\u2211 (f : <{t : I | chi t /\\ psi t} -> X t [ chi t /\\ psi t /\\ phi t |-> a t ]>), <{t : I | chi t} -> X t [ chi t /\\ psi t |-> f t ]>) := \\I -> \\chi -> \\psi -> \\phi -> \\X -> \\a -> (\\h -> (\\{t : I | chi t /\\ psi t} -> h t, \\{t : I | chi t} -> h t), ((\\fg -> \\{t : I | chi t} -> (second fg) t, \\h -> refl_{h}), ((\\fg -> \\{t : I | chi t} -> (second fg) t, \\h -> refl_{h})))) -- [RS17, Theorem 4.5] #def cofibration_union : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (X : <{t : I | phi t \\/ psi t} -> U >) -> (a : <{t : I | psi t} -> X t >) -> Eq <{t : I | phi t \\/ psi t} -> X t [ psi t |-> a t ]> <{t : I | phi t} -> X t [ phi t /\\ psi t |-> a t ]> := \\I -> \\phi -> \\psi -> \\X -> \\a -> (\\h -> \\{t : I | phi t} -> h t, ((\\g -> \\{t : I | phi t \\/ psi t} -> recOR(phi t, psi t, g t, a t), \\h -> refl_{h}), (\\g -> \\{t : I | phi t \\/ psi t} -> recOR(phi t, psi t, g t, a t), \\h -> refl_{h})))","title":"Composites and unions of cofibrations"},{"location":"simplicial-hott/04-extension-types/#relative-function-extensionality","text":"A more complete treatment still needs to be done. -- [RS17, Proposition 4.8(ii)] -- as suggested by footnote 8, we assert this as an \"extension extensionality\" axiom #def ExtExt : U := (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (A : <{t : I | psi t } -> U >) -> (a : <{t : I | phi t } -> A t >) -> (f : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ phi t |-> a t ]>) -> (_ : <{t : I | psi t} -> (f t = g t) [ phi t |-> refl ]>) -> (f =_{<{t : I | psi t} -> A t [ phi t |-> a t ]>} g) -- A fiberwise equivalence defines an equivalence of extension types, for simplicity extending from BOT #def fibered-equiv-extension-equiv : (_ : ExtExt) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (A : <{t : I | psi t } -> U >) -> (B : <{t : I | psi t } -> U >) -> (_ : <{t : I | psi t } -> (Eq (A t) (B t)) >) -> Eq (<{t : I | psi t } -> A t >) (<{t : I | psi t } -> B t >) := \\extext -> \\I -> \\psi -> \\A -> \\B -> \\fibequiv -> ((\\a -> \\{t : I | psi t } -> (first (fibequiv t)) (a t)), (((\\b -> \\{t : I | psi t } -> (first (first (second (fibequiv t)))) (b t)), \\a -> extext I psi (\\{t : I | psi t} -> BOT) A (\\{u : I | BOT} -> recBOT) (\\{t : I | psi t} -> (first (first (second (fibequiv t)))) ((first (fibequiv t)) (a t))) a (\\{t : I | psi t} -> (second (first (second (fibequiv t)))) (a t))), ((\\b -> \\{t : I | psi t } -> (first (second (second (fibequiv t)))) (b t)), (\\b -> extext I psi (\\{t : I | psi t} -> BOT) B (\\{u : I | BOT} -> recBOT) (\\{t : I | psi t} -> (first (fibequiv t)) ((first (second (second (fibequiv t)))) (b t))) b (\\{t : I | psi t} -> (second (second (second (fibequiv t)))) (b t))))))","title":"Relative function extensionality"},{"location":"simplicial-hott/05-segal-types/","text":"Segal Types These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites hott/total-space.rzk \u2014 we rely on contractible-fibers-projection-equiv and total-space-projection from that file in the proof of Theorem 5.5 3-simplicial-type-theory.rzk \u2014 we rely on definitions of simplicies and their subshapes The Segal condition -- [RS17, Definition 5.1] -- The type of arrows in A from x to y #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U := (t : \u0394\u00b9) -> A [ -- (hom A x y) is a 1-simplex (an arrow) in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U := { (t1, t2) : \u0394\u00b2 } -> A [ -- (hom2 A x y z f g h) is a 2-simplex (triangle) in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] -- [RS17, Definition 5.3] -- A type is Segal if every composable pair of arrows has a unique composite #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) -- Segal types have a composition functor; written in diagrammatic order to match the order of arguments in isSegal #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) -- If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) =_{hom A x z} h := total-path-to-base-path (hom A x z) (\\(k : hom A x z) -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha)) Characterizing Segal types -- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> -- \\{(t, s) : 2 * 2 | \u039b (t, s) } -> -- try \\{(t, s) : \u039b } or with () recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) -- A type. (alpha : \u0394\u00b2 -> A) -- A commutative triangle. : \u039b -> A := \\t -> alpha t -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}), (\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl -- Theorem 5.5 justifies an alternate definition of isSegal #def isSegal' (A : U) -- A type. : U := isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (horn-restriction A) #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5]; these notions are equivalent, not just logically equivalent, because they are both propositions over A #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A) -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality defined in 4-equivalences.rzk (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal))) Identity -- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f) Associativity #def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing two copies of the triangle along the common diagonal edge. := \\(t, s) -> recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) -- for use in the proof of associativity #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) -- the Segal-comp-witness-square as an arrow in the arrow type #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h) Homotopies To be done. Anodyne maps To be done.","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types/#segal-types","text":"These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Segal Types"},{"location":"simplicial-hott/05-segal-types/#prerequisites","text":"hott/total-space.rzk \u2014 we rely on contractible-fibers-projection-equiv and total-space-projection from that file in the proof of Theorem 5.5 3-simplicial-type-theory.rzk \u2014 we rely on definitions of simplicies and their subshapes","title":"Prerequisites"},{"location":"simplicial-hott/05-segal-types/#the-segal-condition","text":"-- [RS17, Definition 5.1] -- The type of arrows in A from x to y #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U := (t : \u0394\u00b9) -> A [ -- (hom A x y) is a 1-simplex (an arrow) in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U := { (t1, t2) : \u0394\u00b2 } -> A [ -- (hom2 A x y z f g h) is a 2-simplex (triangle) in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] -- [RS17, Definition 5.3] -- A type is Segal if every composable pair of arrows has a unique composite #def isSegal (A : U) -- A type. : U := (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> isContr( \u2211 (h : hom A x z), hom2 A x y z f g h) -- Segal types have a composition functor; written in diagrammatic order to match the order of arguments in isSegal #def Segal-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom A x z := first (first (AisSegal x y z f g)) -- Segal types have composition witnesses #def Segal-comp-witness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom2 A x y z f g (Segal-comp A AisSegal x y z f g) := second (first (AisSegal x y z f g)) -- If there is a witness that an arrow h is a composite of f and g, then the specified composite equals h. #def Segal-comp-uniqueness (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. (alpha : hom2 A x y z f g h) -- A witness that h is a composite of f and g. : (Segal-comp A AisSegal x y z f g) =_{hom A x z} h := total-path-to-base-path (hom A x z) (\\(k : hom A x z) -> hom2 A x y z f g k) (Segal-comp A AisSegal x y z f g, Segal-comp-witness A AisSegal x y z f g) (h, alpha) (contracting-htpy (\u2211 (k : hom A x z), hom2 A x y z f g k) (AisSegal x y z f g) (h, alpha))","title":"The Segal condition"},{"location":"simplicial-hott/05-segal-types/#characterizing-segal-types","text":"-- A pair of composable arrows form a horn. #def horn (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u039b -> A := \\(t, s) -> -- \\{(t, s) : 2 * 2 | \u039b (t, s) } -> -- try \\{(t, s) : \u039b } or with () recOR( s === 0_2 |-> f t, t === 1_2 |-> g s ) -- The underlying horn of a simplex #def horn-restriction (A : U) -- A type. (alpha : \u0394\u00b2 -> A) -- A commutative triangle. : \u039b -> A := \\t -> alpha t -- Here, we prove the equivalence used in [RS17, Theorem 5.5]. -- However, we do this by constructing the equivalence directly, -- instead of using a composition of equivalences, as it is easier to write down -- and it computes better (we can use refl for the witnesses of the equivalence). #def compositions-are-horn-fillings (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : Eq (\u2211 (h : hom A x z), hom2 A x y z f g h) <{t : 2 * 2 | \u0394\u00b2 t } -> A [ \u039b t |-> horn A x y z f g t ]> := (\\hh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second hh) t, ((\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}), (\\k -> (\\(t : 2) -> k (t, t), \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> k (t, s)), \\hh -> refl_{hh}))) #def restriction-equiv (A : U) -- A type. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) := (\\k -> (\\{t : 2 * 2 | \u039b t} -> k t, (\\(t : 2) -> k (t, t), \\{t : 2 * 2 | \u0394\u00b2 t} -> k t)), ((\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}), (\\khh -> \\{t : 2 * 2 | \u0394\u00b2 t} -> (second (second khh)) t, \\k -> refl_{k}))) -- [RS17, Theorem 5.5], the hard direction: #def Segal-restriction-equiv (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) -- (horn-restriction A) := compose_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u039b t} -> A >) (restriction-equiv A) (total-space-projection (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h), (contractible-fibers-projection-equiv (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (\\k -> AisSegal (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t))))) -- Verify that the mapping in (Segal-restriction-equiv A AisSegal) -- is exactly (horn-restriction A) #def Segal-restriction-equiv-test (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : (first (Segal-restriction-equiv A AisSegal)) = (horn-restriction A) := refl -- Theorem 5.5 justifies an alternate definition of isSegal #def isSegal' (A : U) -- A type. : U := isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (horn-restriction A) #def isSegal-isSegal' (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal' A := second (Segal-restriction-equiv A AisSegal) #def isSegal'-isSegal (A : U) -- A type. (AisSegal' : isSegal' A) -- A proof that A is Segal'. : isSegal A := \\x y z f g -> (projection-equiv-contractible-fibers (<{t : 2 * 2 | \u039b t} -> A >) (\\k -> \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (second (compose_Eq (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (<{t : 2 * 2 | \u039b t} -> A >) (sym_Eq (<{t : 2 * 2 | \u0394\u00b2 t} -> A >) (\u2211 (k : <{t : 2 * 2 | \u039b t} -> A >), \u2211 (h : hom A (k (0_2, 0_2)) (k (1_2, 1_2))), hom2 A (k (0_2, 0_2)) (k (1_2, 0_2)) (k (1_2, 1_2)) (\\t -> k (t, 0_2)) (\\t -> k (1_2, t)) h) (restriction-equiv A)) (horn-restriction A, AisSegal') ))) (horn A x y z f g) -- [RS17, Theorem 5.5]; these notions are equivalent, not just logically equivalent, because they are both propositions over A #def isSegal-iff-isSegal' (A : U) -- A type. : iff (isSegal A) (isSegal' A) := (isSegal-isSegal' A , isSegal'-isSegal A) -- [RS17, Corollary 5.6(i)] : if X is a type and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-function-types (funext : FunExt) -- This proof uses function extensionality defined in 4-equivalences.rzk (X : U) -- A type. (A : (_ : X) -> U) -- A type family (fiberwiseAisSegal : (x : X) -> isSegal' (A x)) -- An assumption that the fibers are Segal types. : isSegal' ((x : X) -> A x) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> ((x : X) -> A x) >) ((x : X) -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) ((x : X) -> <{t : 2 * 2 | \u039b t} -> A x >) (<{t : 2 * 2 | \u039b t} -> ((x : X) -> A x) >) (\\g -> \\x -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t x) -- first equivalence (second (flip-ext-fun (2 * 2) \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) X (\\{t : 2 * 2 | \u0394\u00b2 t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) (\\h -> \\x -> \\{t : 2 * 2 | \u039b t} -> h x t) -- second equivalence (second (fibered-equiv-function-equiv funext X (\\x -> <{t : 2 * 2 | \u0394\u00b2 t} -> A x >) (\\x -> <{t : 2 * 2 | \u039b t} -> A x >) (\\x -> (horn-restriction (A x) , fiberwiseAisSegal x)))) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\x -> (h x) t) -- third equivalence (second(flip-ext-fun-inv (2 * 2) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) X (\\{t : 2 * 2 | \u039b t} -> A) (\\{t : 2 * 2 | BOT} -> recBOT))) -- [RS17, Corollary 5.6(ii)] : if X is a shape and A : X -> U is such that A(x) is a Segal type then (x : X) -> A x is a Segal type #def Segal-extension-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (I : CUBE) -- A cube. (psi : (s : I) -> TOPE) -- A tope. (A : <{s : I | psi s} -> U >) -- An extension type. (fiberwiseAisSegal : <{s : I | psi s} -> isSegal' (A s) >) -- An assumption that the fibers are Segal types. : isSegal' (<{s : I | psi s} -> A s >) := triple_compose_isEquiv (<{t : 2 * 2 | \u0394\u00b2 t} -> <{s : I | psi s} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s > >) (<{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s > >) (<{t : 2 * 2 | \u039b t} -> <{s : I | psi s} -> A s > >) (\\g -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u0394\u00b2 t} -> g t s) -- first equivalence (second(fubini (2 * 2) I \u0394\u00b2 (\\{t : 2 * 2 | \u0394\u00b2 t} -> BOT) psi (\\{s : I | psi s} -> BOT) (\\{t : 2 * 2 | \u0394\u00b2 t} -> \\{s : I | psi s} -> A s) (\\{u : (2 * 2) * I | BOT} -> recBOT))) (\\h -> \\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> h s t) -- second equivalence (second (fibered-equiv-extension-equiv extext I psi (\\{s : I | psi s} -> <{t : 2 * 2 | \u0394\u00b2 t} -> A s >) (\\{s : I | psi s} -> <{t : 2 * 2 | \u039b t} -> A s >) (\\{s : I | psi s} -> (horn-restriction (A s), fiberwiseAisSegal s)) )) (\\h -> \\{t : 2 * 2 | \u039b t} -> \\{s : I | psi s} -> (h s) t) -- third equivalence (second(fubini I (2 * 2) psi (\\{s : I | psi s} -> BOT) \u039b (\\{t : 2 * 2 | \u039b t} -> BOT) (\\{s : I | psi s} -> \\{t : 2 * 2 | \u039b t} -> A s) (\\{u : I * (2 * 2) | BOT} -> recBOT))) -- The type of arrows in a type. #def arr -- A type (A : U) : U := (t : \u0394\u00b9) -> A -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal'. #def Segal'-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal' A) -- A proof that A isSegal'. : isSegal' (arr A) := Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> AisSegal) -- A special case of [RS17, Corollary 5.6(ii)], using is-Segal. #def Segal-arrow-types (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. : isSegal (arr A) := isSegal'-isSegal (arr A) (Segal-extension-types extext 2 \u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> A) (\\{t : 2 | \u0394\u00b9 t} -> (isSegal-isSegal' A AisSegal)))","title":"Characterizing Segal types"},{"location":"simplicial-hott/05-segal-types/#identity","text":"-- [RS17, Definition 5.7] -- all types have identity arrows #def id-arr (A : U) -- A type. (x : A) -- A point in A. : hom A x x := \\{t : 2 | \u0394\u00b9 t} -> x -- [RS17, Proposition 5.8a] -- the right unit law for identity #def comp-id-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x y y f (id-arr A y) f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f t -- If A is Segal then the right unit law holds #def Segal-comp-id (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x y y f (id-arr A y)) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x y y f (id-arr A y) f (comp-id-witness A x y f) -- [RS17, Proposition 5.8b] -- the left unit law for identity #def id-comp-witness (A : U) -- A type. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : hom2 A x x y (id-arr A x) f f := \\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -> f s -- If A is Segal then the left unit law holds #def Segal-id-comp (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y : A) -- Two points in A. (f : hom A x y) -- An arrow from x to y in A. : (Segal-comp A AisSegal x x y (id-arr A x) f) =_{hom A x y} f := Segal-comp-uniqueness A AisSegal x x y (id-arr A x) f f (id-comp-witness A x y f)","title":"Identity"},{"location":"simplicial-hott/05-segal-types/#associativity","text":"#def unfolding-square (A : U) -- A type. (triangle : \u0394\u00b2 -> A) -- A triangle in A. : \u0394\u00b9\u00d7\u0394\u00b9 -> A -- A square in A, defined by gluing two copies of the triangle along the common diagonal edge. := \\(t, s) -> recOR(t <= s |-> triangle (s , t), s <= t |-> triangle (t , s)) -- for use in the proof of associativity #def Segal-comp-witness-square (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : \u0394\u00b9\u00d7\u0394\u00b9 -> A := unfolding-square A (Segal-comp-witness A AisSegal x y z f g) -- the Segal-comp-witness-square as an arrow in the arrow type #def Segal-arr-in-arr (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. : hom (arr A) f g := \\t -> \\s -> (Segal-comp-witness-square A AisSegal x y z f g) (t, s) #def Segal-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 (arr A) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h) (Segal-comp (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) := (Segal-comp-witness (arr A) (Segal-arrow-types extext A AisSegal) f g h (Segal-arr-in-arr A AisSegal w x y f g) (Segal-arr-in-arr A AisSegal x y z g h)) -- The Segal-associativity-witness curries to define a diagram \u0394\u00b2\u00d7\u0394\u00b9 -> A. -- The Segal-associativity-tetrahedron is extracted via the middle-simplex map \\((t, s), r) -> ((t, r), s) from \u0394\u00b3 to \u0394\u00b2\u00d7\u0394\u00b9 #def Segal-associativity-tetrahedron (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : \u0394\u00b3 -> A := \\((t, s), r) -> (Segal-associativity-witness extext A AisSegal w x y z f g h) (t, r) s -- the diagonal composite of three arrows extracted from the Segal-associativity-tetrahedron #def Segal-triple-composite (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom A w z := \\t -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), t) #def Segal-left-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, t), s) #def Segal-right-associativity-witness (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : hom2 A w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) := \\(t, s) -> (Segal-associativity-tetrahedron extext A AisSegal w x y z f g h) ((t, s), s) #def Segal-left-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w y z (Segal-comp A AisSegal w x y f g) h (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-left-associativity-witness extext A AisSegal w x y z f g h) #def Segal-right-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) = (Segal-triple-composite extext A AisSegal w x y z f g h) := Segal-comp-uniqueness A AisSegal w x z f (Segal-comp A AisSegal x y z g h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-right-associativity-witness extext A AisSegal w x y z f g h) #def Segal-associativity (extext : ExtExt) -- This proof uses extension extensionality, defined in 4-extension-types.md (A : U) -- A type. (AisSegal : isSegal A) -- A proof that A is Segal. (w x y z : A) -- Four points in A. (f : hom A w x) -- An arrow in A from w to x. (g : hom A x y) -- An arrow in A from x to y. (h : hom A y z) -- An arrow in A from y to z. : (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) = (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) := zig-zag-concat (hom A w z) (Segal-comp A AisSegal w y z (Segal-comp A AisSegal w x y f g) h) (Segal-triple-composite extext A AisSegal w x y z f g h) (Segal-comp A AisSegal w x z f (Segal-comp A AisSegal x y z g h)) (Segal-left-associativity extext A AisSegal w x y z f g h) (Segal-right-associativity extext A AisSegal w x y z f g h)","title":"Associativity"},{"location":"simplicial-hott/05-segal-types/#homotopies","text":"To be done.","title":"Homotopies"},{"location":"simplicial-hott/05-segal-types/#anodyne-maps","text":"To be done.","title":"Anodyne maps"},{"location":"simplicial-hott/06-2cat-of-segal-types/","text":"The 2-category of Segal types These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites TODO -- [RS17, Section 6.1] -- Action of maps on homs #def ap : (A : U) -> (B : U) -> (F : (x : A) -> B) -> (x : A) -> (y : A) -> (f : hom A x y) -> hom B (F x) (F y) := \\A -> \\B -> \\F -> \\x -> \\y -> \\f -> (\\t -> (F (f t))) -- [RS17, Proposition 6.1] -- Preservation of identities #def functors-pres-id : (_ : ExtExt) -> (A : U) -> (AisSegal : isSegal A) -> (B : U) -> (BisSegal : isSegal B) -> (F : (x : A) -> B) -> ( (x : A) -> (ap A B F x x (id-arr A x)) =_{hom B (F x) (F x)} (id-arr B (F x)) ) := \\extext -> \\A -> \\AisSegal -> \\B -> \\BisSegal -> \\F -> (\\x -> extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> B) (\\t -> recOR(t === 0_2, t === 1_2, F x, F x)) (ap A B F x x (id-arr A x)) (id-arr B (F x)) (\\{t : 2 | \u0394\u00b9 t} -> refl_{F x}) )","title":"2-Category of Segal Types"},{"location":"simplicial-hott/06-2cat-of-segal-types/#the-2-category-of-segal-types","text":"These formalisations correspond to Section 6 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"The 2-category of Segal types"},{"location":"simplicial-hott/06-2cat-of-segal-types/#prerequisites","text":"TODO -- [RS17, Section 6.1] -- Action of maps on homs #def ap : (A : U) -> (B : U) -> (F : (x : A) -> B) -> (x : A) -> (y : A) -> (f : hom A x y) -> hom B (F x) (F y) := \\A -> \\B -> \\F -> \\x -> \\y -> \\f -> (\\t -> (F (f t))) -- [RS17, Proposition 6.1] -- Preservation of identities #def functors-pres-id : (_ : ExtExt) -> (A : U) -> (AisSegal : isSegal A) -> (B : U) -> (BisSegal : isSegal B) -> (F : (x : A) -> B) -> ( (x : A) -> (ap A B F x x (id-arr A x)) =_{hom B (F x) (F x)} (id-arr B (F x)) ) := \\extext -> \\A -> \\AisSegal -> \\B -> \\BisSegal -> \\F -> (\\x -> extext 2 \u0394\u00b9 \u2202\u0394\u00b9 (\\{t : 2 | \u0394\u00b9 t} -> B) (\\t -> recOR(t === 0_2, t === 1_2, F x, F x)) (ap A B F x x (id-arr A x)) (id-arr B (F x)) (\\{t : 2 | \u0394\u00b9 t} -> refl_{F x}) )","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete/","text":"Discrete types These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites TODO The definition -- [RS17, Definition 7.1] -- Discrete types are types in which the hom-types are canonically equivalent to identity types. #def id-to-arr : (A : U) -> (x : A) -> (y : A) -> (_ : x =_{A} y) -> hom A x y := \\A -> \\x -> \\y -> \\p -> idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete : (A : U) -> U := \\A -> (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"Discrete Types"},{"location":"simplicial-hott/07-discrete/#discrete-types","text":"These formalisations correspond to Section 7 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Discrete types"},{"location":"simplicial-hott/07-discrete/#prerequisites","text":"TODO","title":"Prerequisites"},{"location":"simplicial-hott/07-discrete/#the-definition","text":"-- [RS17, Definition 7.1] -- Discrete types are types in which the hom-types are canonically equivalent to identity types. #def id-to-arr : (A : U) -> (x : A) -> (y : A) -> (_ : x =_{A} y) -> hom A x y := \\A -> \\x -> \\y -> \\p -> idJ(A, x, \\y' -> \\p' -> hom A x y', (id-arr A x), y, p) #def isDiscrete : (A : U) -> U := \\A -> (x : A) -> (y : A) -> isEquiv (x =_{A} y) (hom A x y) (id-to-arr A x y)","title":"The definition"},{"location":"simplicial-hott/08-covariant/","text":"Covariantly functorial type families These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1 Prerequisites TODO -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> \\v -> <{t : 2 | \u0394\u00b9 t } -> C (f t) [ \u2202\u0394\u00b9 t |-> recOR(t === 0_2, t === 1_2, u, v) ]> -- dependent hom with specified domain #def dhomFrom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> (\u2211 (v : C y), dhom A x y f C u v) -- [RS17, Section 8 Prelim] #def dhom2 : (A : U) -> (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> (h : hom A x z) -> (alpha : hom2 A x y z f g h) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> (w : C z) -> (ff : dhom A x y f C u v) -> (gg : dhom A y z g C v w) -> (hh : dhom A x z h C u w) -> U := \\A -> \\x -> \\y -> \\z -> \\f -> \\g -> \\h -> \\alpha -> \\C -> \\u -> \\v -> \\w -> \\ff -> \\gg -> \\hh -> <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [ \u2202\u0394\u00b2 (t1, t2) |-> recOR(t2 === 0_2, t1 === 1_2 \\/ t2 === t1, ff t1, recOR(t1 === 1_2, t2 === t1, gg t2, hh t2)) ]> -- [RS17, Definition 8.2] #def isCovFam : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> isContr (\u2211 (v : C y), dhom A x y f C u v) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C) -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (C : A -> U) (CisCov : isCovFam A C) (x y : A) (f : hom A x y) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift : (A : U) -> (C : A -> U) -> (CisCov : isCovFam A C) -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> (dhom A x y f C u (covTrans A C CisCov x y f u)) := \\A -> \\C -> \\CisCov -> \\x -> \\y -> \\f -> \\u -> second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, Remark 8.3] -- TODO: Seems broken ATM -- #def reindexOfCovFamIsCov : (A : U) -> (B : U) -> (F : (b : B) -> A) -> (C : (a : A) -> U) -> (AisCovFam : isCovFam A C) -> (isCovFam B (reindex A B F C)) -- := \\A -> \\B -> \\F -> \\C -> \\AisCovFam -> \\x -> \\y -> \\f -> \\u -> -- ( -- (contraction-center (\u2211 (v : C (F y)), -- (dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u), -- (contracting-htpy (\u2211 (v : C (F y)), -- dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u) -- ) -- ) -- [RS17, alternative def. from Proposition 8.4] #def isCovFam' : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr <{t : 2 | \u0394\u00b9 t} -> C(f t) > -- [RS17, Proposition 8.4] -- We should prove this in one step since this amounts to transporting along equivalent types of lifting --#def isCovFam-iff-CovFam' : (A : U) -> (C : (a : A) -> (_ : isCovFam A C) -> --isCovFam' A C -- := TODO -- [RS17, Proposition 8.16, Part 1] -- Covariant families preserve composition -- #def covPresComp -- (A : U) -- (C : A -> U) -- (x y z : A) -- (f : hom A x y) -- (g : hom A y z) -- (h : hom A x z) -- (u : C x) -- -> TODO -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities -- #def covPresId -- (A : U) -- (C : A -> U) -- (CisCov : isCovFam A C) -- (x : A) : (homotopy -- (C x) -- (C x) -- (\\u -> (covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- := \\u -> (first (contractible-connecting-htpy -- (dhomFrom A x x (id-arr A x) C u) -- (CisCov) -- ((covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- ) -- covTrans : (A : U) -> (C : A -> U) -> (_ : isCovFam A C) -- -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> C y -- :=","title":"Covariantly Functorial Type Families"},{"location":"simplicial-hott/08-covariant/#covariantly-functorial-type-families","text":"These formalisations correspond to Section 8 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Covariantly functorial type families"},{"location":"simplicial-hott/08-covariant/#prerequisites","text":"TODO -- [RS17, Section 8 Prelim] -- The type of dependent arrows in C over f from u to v #def dhom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> \\v -> <{t : 2 | \u0394\u00b9 t } -> C (f t) [ \u2202\u0394\u00b9 t |-> recOR(t === 0_2, t === 1_2, u, v) ]> -- dependent hom with specified domain #def dhomFrom : (A : U) -> (x : A) -> (y : A) -> (f : hom A x y) -> (C : (x : A) -> U) -> (u : C x) -> U := \\A -> \\x -> \\y -> \\f -> \\C -> \\u -> (\u2211 (v : C y), dhom A x y f C u v) -- [RS17, Section 8 Prelim] #def dhom2 : (A : U) -> (x : A) -> (y : A) -> (z : A) -> (f : hom A x y) -> (g : hom A y z) -> (h : hom A x z) -> (alpha : hom2 A x y z f g h) -> (C : (x : A) -> U) -> (u : C x) -> (v : C y) -> (w : C z) -> (ff : dhom A x y f C u v) -> (gg : dhom A y z g C v w) -> (hh : dhom A x z h C u w) -> U := \\A -> \\x -> \\y -> \\z -> \\f -> \\g -> \\h -> \\alpha -> \\C -> \\u -> \\v -> \\w -> \\ff -> \\gg -> \\hh -> <{(t1, t2) : 2 * 2 | \u0394\u00b2 (t1, t2)} -> C (alpha (t1, t2)) [ \u2202\u0394\u00b2 (t1, t2) |-> recOR(t2 === 0_2, t1 === 1_2 \\/ t2 === t1, ff t1, recOR(t1 === 1_2, t2 === t1, gg t2, hh t2)) ]> -- [RS17, Definition 8.2] #def isCovFam : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> isContr (\u2211 (v : C y), dhom A x y f C u v) -> isContr (dhomFrom A x y f C u) -- Type of covariant families over a fixed type #def covFam (A : U) : U := (\u2211 (C : ((a : A) -> U)), isCovFam A C) -- [RS17, covariant transport from beginning of Section 8.2] #def covTrans (A : U) (C : A -> U) (CisCov : isCovFam A C) (x y : A) (f : hom A x y) (u : C x) : C y := first (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, covariant lift from beginning of Section 8.2] #def covLift : (A : U) -> (C : A -> U) -> (CisCov : isCovFam A C) -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> (dhom A x y f C u (covTrans A C CisCov x y f u)) := \\A -> \\C -> \\CisCov -> \\x -> \\y -> \\f -> \\u -> second (contraction-center (dhomFrom A x y f C u) (CisCov x y f u)) -- [RS17, Remark 8.3] -- TODO: Seems broken ATM -- #def reindexOfCovFamIsCov : (A : U) -> (B : U) -> (F : (b : B) -> A) -> (C : (a : A) -> U) -> (AisCovFam : isCovFam A C) -> (isCovFam B (reindex A B F C)) -- := \\A -> \\B -> \\F -> \\C -> \\AisCovFam -> \\x -> \\y -> \\f -> \\u -> -- ( -- (contraction-center (\u2211 (v : C (F y)), -- (dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u), -- (contracting-htpy (\u2211 (v : C (F y)), -- dhom A (F x) (F y) (ap B A F x y f) C u v)) -- (AisCovFam (F x) (F y) (ap B A F x y f) u) -- ) -- ) -- [RS17, alternative def. from Proposition 8.4] #def isCovFam' : (A : U) -> (C : (a : A) -> U) -> U := \\A -> \\C -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -> isContr <{t : 2 | \u0394\u00b9 t} -> C(f t) > -- [RS17, Proposition 8.4] -- We should prove this in one step since this amounts to transporting along equivalent types of lifting --#def isCovFam-iff-CovFam' : (A : U) -> (C : (a : A) -> (_ : isCovFam A C) -> --isCovFam' A C -- := TODO -- [RS17, Proposition 8.16, Part 1] -- Covariant families preserve composition -- #def covPresComp -- (A : U) -- (C : A -> U) -- (x y z : A) -- (f : hom A x y) -- (g : hom A y z) -- (h : hom A x z) -- (u : C x) -- -> TODO -- [RS17, Proposition 8.16, Part 2] -- Covariant families preserve identities -- #def covPresId -- (A : U) -- (C : A -> U) -- (CisCov : isCovFam A C) -- (x : A) : (homotopy -- (C x) -- (C x) -- (\\u -> (covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- := \\u -> (first (contractible-connecting-htpy -- (dhomFrom A x x (id-arr A x) C u) -- (CisCov) -- ((covTrans A C CisCov x x (id-arr A x) u)) -- (identity (C x)) -- ) -- ) -- covTrans : (A : U) -> (C : A -> U) -> (_ : isCovFam A C) -- -> (x : A) -> (y : A) -> (f : hom A x y) -> (u : C x) -- -> C y -- :=","title":"Prerequisites"},{"location":"simplicial-hott/09-yoneda/","text":"The Yoneda lemma These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 -- [RS17, Section 9] -- Definition of evid and the Yoneda map as its claimed inverse -- Auxiliary definition of the type of \"generalized elements\" of C at a:A #def genElts (A : U) (C : A -> U) (a : A) : U := ( (x : A) -> hom A a x -> C x) #def evid : (A : U) -> (C : A -> U) -> (a : A) -> (genElts A C a) -> C a := \\A -> \\C -> \\a -> \\f -> (f a (id-arr A a)) #def yon (A : U) (C : A -> U) (CisCov : isCovFam A C) (a : A) : (C a) -> (genElts A C a) := \\u -> \\x -> \\f -> covTrans A C CisCov a x f u -- #def -- yon.evid-is-id -- (A : U) -- (AisSegal : isSegal A) -- (C : A -> U) -- (CisCov : isCovFam C) -- (a : A) -- : (genElts A C a) -- -> (homotopy (genElts A C a) -- (genElts A C a) -- (id-arr genElts A C a) -- (comp (genElts A C a) (C a) (evid A C a) (yon A C CisCov a)) -- ) -- := TODO","title":"The Yoneda Lemma"},{"location":"simplicial-hott/09-yoneda/#the-yoneda-lemma","text":"These formalisations correspond to Section 5 of RS17 paper. This is a literate rzk file: #lang rzk-1 -- [RS17, Section 9] -- Definition of evid and the Yoneda map as its claimed inverse -- Auxiliary definition of the type of \"generalized elements\" of C at a:A #def genElts (A : U) (C : A -> U) (a : A) : U := ( (x : A) -> hom A a x -> C x) #def evid : (A : U) -> (C : A -> U) -> (a : A) -> (genElts A C a) -> C a := \\A -> \\C -> \\a -> \\f -> (f a (id-arr A a)) #def yon (A : U) (C : A -> U) (CisCov : isCovFam A C) (a : A) : (C a) -> (genElts A C a) := \\u -> \\x -> \\f -> covTrans A C CisCov a x f u -- #def -- yon.evid-is-id -- (A : U) -- (AisSegal : isSegal A) -- (C : A -> U) -- (CisCov : isCovFam C) -- (a : A) -- : (genElts A C a) -- -> (homotopy (genElts A C a) -- (genElts A C a) -- (id-arr genElts A C a) -- (comp (genElts A C a) (C a) (evid A C a) (yon A C CisCov a)) -- ) -- := TODO","title":"The Yoneda lemma"},{"location":"simplicial-hott/10-rezk-types/","text":"10. Rezk Types These formalisations correspond to Section 10 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Rezk Types"},{"location":"simplicial-hott/10-rezk-types/#10-rezk-types","text":"These formalisations correspond to Section 10 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"10. Rezk Types"},{"location":"simplicial-hott/11-adjunctions/","text":"11. Adjunctions These formalisations correspond to Section 11 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"Adjunctions"},{"location":"simplicial-hott/11-adjunctions/#11-adjunctions","text":"These formalisations correspond to Section 11 of RS17 paper. This is a literate rzk file: #lang rzk-1","title":"11. Adjunctions"}]}